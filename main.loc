module root-r (*)

import root

type R => Unit = "NULL"
type R => Int = "integer"
type R => Real = "numeric"
type R => Str = "character"
type R => Bool = "logical"
type R => (Map a b) = "list" a b
type R => (List a) = "list" a
type R => (Tuple2 a b) = "list" a b
type R => (Tuple3 a b c) = "list" a b c
type R => (Tuple4 a b c d) = "list" a b c d
type R => (Tuple5 a b c d e) = "list" a b c d e
type R => (Tuple6 a b c d e f) = "list" a b c d e f
type R => (Tuple7 a b c d e f g) = "list" a b c d e f g
type R => (Tuple8 a b c d e f g h) = "list" a b c d e f g h

--' An identity function used to force R usage
idr a :: a -> a

source R from "R/core.R"
    ( "morloc_idr" as idr
    , "morloc_toFst" as toFst
    , "morloc_toSnd" as toSnd
    , "morloc_ifelse" as ifelse
    , "morloc_branch" as branch
    , "morloc_not" as not
    , "morloc_and" as (&&)
    , "morloc_or" as (||)
    , "morloc_zipWith" as zipWith
    , "rev" as reverse
    , "morloc_sort" as sort
    , "morloc_sortBy" as sortBy
    , "Filter" as filter
    , "morloc_unzip" as unzip
    , "morloc_replicate" as replicate
    , "morloc_takeWhile" as takeWhile
    , "morloc_dropWhile" as dropWhile
    , "morloc_partition" as partition
    , "morloc_scanl" as scanl
    , "morloc_enumerate" as enumerate
    , "morloc_intersperse" as intersperse
    , "morloc_keys" as keys
    , "morloc_vals" as values
    , "morloc_lookup" as lookup
    , "morloc_insert" as insert
    , "morloc_delete" as delete
    , "morloc_from_list" as fromList
    , "morloc_to_list" as toList
    , "morloc_map_val" as mapValues
    , "morloc_map_key" as mapKeys
    , "morloc_filter_map" as filterMap
    )

instance Eq a where
  source R from "R/core.R" ("morloc_eq" as (==))

instance Ord a where
  source R from "R/core.R" ("morloc_le" as (<=))

instance Integral Int where
  source R from "R/core.R"
    ( "morloc_neg" as neg
    , "morloc_abs" as abs
    , "morloc_add" as (+)
    , "morloc_sub" as (-)
    , "morloc_mul" as (*)
    , "morloc_intdiv" as (//)
    , "morloc_mod" as (%)
    )
  zero = 0

instance Integral Real where
  source R from "R/core.R"
    ( "morloc_neg" as neg
    , "morloc_abs" as abs
    , "morloc_add" as (+)
    , "morloc_sub" as (-)
    , "morloc_mul" as (*)
    , "morloc_div" as (//)
    , "morloc_mod" as (%)
    )
  zero = 0.0

instance Numeric Real where
  source R from "R/core.R"
    ( "morloc_inv" as inv
    , "morloc_div" as (/)
    , "morloc_pow" as (**)
    , "morloc_ln" as ln
    )

instance Monoid Str where
  mempty = ""
  source R from "R/core.R" ("morloc_str_add" as (<>))

instance Monoid (List a) where
  mempty = []
  source R from "R/core.R" ("c" as (<>))


instance Foldable List where
  source R from "R/core.R" ("morloc_fold" as fold)

instance Functor List where
  source R from "R/core.R" ("morloc_map" as map)

instance Sequence List where
  empty = []
  source R from "R/core.R"
    ( "morloc_at" as at
    , "morloc_slice" as slice
    )

instance Show a where
  source R from "R/core.R" ("morloc_show" as show)

-------------------------------------------------------------------------------
--                 Pack and Unpack internal functions
-- These functions are used by morloc internally for (de)serialization of types
-- that cannot be automatically (de)serialized into/from JSON. They should not
-- be exported.
-------------------------------------------------------------------------------

-- WARNING: The Map implementation in R is total crap. R doesn't have a general
-- map type, at least not in base. The `list` type works properly only for
-- string keys. So the Map type here is mostly just for testing purposes.

instance Packable ([Str],[val]) (Map Str val) where
  source R from "R/data.R"
   ( "morloc_pack_map" as pack
   , "morloc_unpack_map" as unpack
   )

instance Packable (Int) Unit where
  source R from "R/data.R"
   ( "morloc_packUnit" as pack
   , "morloc_unpackUnit" as unpack
   )
